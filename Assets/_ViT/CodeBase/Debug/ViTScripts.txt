Exported: 17.01.2026 15:10:23

using System.Collections;
using UnityEngine;

namespace _ViT.CodeBase
{
    public class GameEventsHandler : MonoBehaviour
    {
        [Header("Pirate Ships Event")]
        [SerializeField] private GameObject pirateShipPrefab;
        [SerializeField] private int pirateShipsCount = 3;
    
        public void OnSeaDetected()
        {
            UnityEngine.Debug.Log($"<color=cyan>‚ïê‚ïê‚ïê OnSeaDetected() –í–´–ó–í–ê–ù! ‚ïê‚ïê‚ïê</color>");
            UnityEngine.Debug.Log($"–ü—Ä–µ—Ñ–∞–±: {(pirateShipPrefab != null ? pirateShipPrefab.name : "–ù–ï –ù–ê–ó–ù–ê–ß–ï–ù!")}");
            UnityEngine.Debug.Log($"–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ: {pirateShipsCount}");
        
            if (pirateShipPrefab == null)
            {
                UnityEngine.Debug.LogError("–ü–†–ï–§–ê–ë –ù–ï –ù–ê–ó–ù–ê–ß–ï–ù! –°–æ–∑–¥–∞—é —Ç–µ—Å—Ç–æ–≤—ã–µ –∫—É–±—ã...");
                SpawnTestCubes();
                return;
            }
        
            StartCoroutine(SpawnShips());
        }
    
        void SpawnTestCubes()
        {
            for (int i = 0; i < pirateShipsCount; i++)
            {
                GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
                Vector3 pos = Camera.main.transform.position + new Vector3(i * 3f, 2, 10f);
                cube.transform.position = pos;
                cube.transform.localScale = new Vector3(2, 1, 3);
                cube.name = $"TestShip_{i}";
                cube.GetComponent<Renderer>().material.color = new Color(0.6f, 0.3f, 0f);
            
                UnityEngine.Debug.Log($"<color=yellow>‚úì Test cube created at {pos}</color>");
            }
        }
    
        IEnumerator SpawnShips()
        {
            for (int i = 0; i < pirateShipsCount; i++)
            {
                Vector3 pos = Camera.main.transform.position + new Vector3(i * 5f, 2, 10f);
                GameObject ship = Instantiate(pirateShipPrefab, pos, Quaternion.identity);
                ship.name = $"PirateShip_{i}";
            
                UnityEngine.Debug.Log($"<color=lime>‚úì Ship spawned: {ship.name} at {pos}</color>");
            
                yield return new WaitForSeconds(0.3f);
            }
        
            UnityEngine.Debug.Log($"<color=lime>‚úì‚úì‚úì –í–°–ï {pirateShipsCount} –ö–û–†–ê–ë–õ–ï–ô –°–û–ó–î–ê–ù–´! ‚úì‚úì‚úì</color>");
        }
    }
}

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.Networking;

namespace _ViT.CodeBase
{
    public class LocalViTSystem : MonoBehaviour
    {
        [Header("Local Server Settings")]
        [SerializeField] private string serverUrl = "http://localhost:8000";
    
        [Header("Detection Settings")]
        [SerializeField] private Camera gameCamera;
        [SerializeField] private float detectionInterval = 3f;
    
        private float confidenceThreshold = 0.05f; // –ñ–Å–°–¢–ö–û 1% - –ª–æ–≤–∏–º –í–°–Å
    
        [Header("Event Rules")]
        [SerializeField] private List<EventRule> eventRules = new List<EventRule>();
    
        private bool isAnalyzing = false;
        private RenderTexture renderTexture;
    
        [System.Serializable]
        public class EventRule
        {
            public string eventName;
            public List<string> requiredLabels = new List<string>();
            [Range(0f, 1f)]
            public float minConfidence = 0.15f;
            public float cooldown = 5f;
            public UnityEvent onEventTriggered;
        
            [HideInInspector] public float lastTriggerTime = -999f;
        }
    
        [System.Serializable]
        private class Prediction
        {
            public string label;
            public float score;
        }
    
        [System.Serializable]
        private class PredictionWrapper
        {
            public Prediction[] predictions;
        }
    
        void Start()
        {
            if (gameCamera == null) gameCamera = Camera.main;
            renderTexture = new RenderTexture(224, 224, 24);
        
            UnityEngine.Debug.Log("LocalViTSystem –∑–∞–ø—É—â–µ–Ω!");
            UnityEngine.Debug.Log($"–°–µ—Ä–≤–µ—Ä: {serverUrl}");
            UnityEngine.Debug.Log($"–ö–∞–º–µ—Ä–∞: {(gameCamera != null ? gameCamera.name : "NULL")}");
        
            if (eventRules.Count == 0)
            {
                eventRules.Add(new EventRule
                {
                    eventName = "Spawn Pirate Ships",
                    requiredLabels = new List<string> { "sea", "ocean", "water", "shore", "lake", "sand", "coast", "beach" },
                    minConfidence = 0.15f,
                    cooldown = 5f
                });
                UnityEngine.Debug.Log("–°–æ–∑–¥–∞–Ω–æ –ø—Ä–∞–≤–∏–ª–æ: Spawn Pirate Ships");
            }
        
            StartCoroutine(CheckServer());
        }
    
        IEnumerator CheckServer()
        {
            UnityEngine.Debug.Log("–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞...");
            UnityWebRequest request = UnityWebRequest.Get($"{serverUrl}/health");
            yield return request.SendWebRequest();
        
            if (request.result == UnityWebRequest.Result.Success)
            {
                UnityEngine.Debug.Log("<color=green>‚úì –°–µ—Ä–≤–µ—Ä —Ä–∞–±–æ—Ç–∞–µ—Ç!</color>");
                StartCoroutine(PeriodicDetection());
            }
            else
            {
                UnityEngine.Debug.LogError($"<color=red>‚úó –°–µ—Ä–≤–µ—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {request.error}</color>");
            }
        }
    
        IEnumerator PeriodicDetection()
        {
            yield return new WaitForSeconds(2f);
            while (true)
            {
                if (!isAnalyzing)
                {
                    yield return StartCoroutine(CaptureAndAnalyze());
                }
                yield return new WaitForSeconds(detectionInterval);
            }
        }
    
        IEnumerator CaptureAndAnalyze()
        {
            isAnalyzing = true;
        
            UnityEngine.Debug.Log("‚Üí –ó–∞—Ö–≤–∞—Ç —Å–∫—Ä–∏–Ω—à–æ—Ç–∞...");
            Texture2D screenshot = CaptureScreenshot();
            byte[] imageBytes = screenshot.EncodeToJPG(85);
            UnityEngine.Debug.Log($"‚Üí –û—Ç–ø—Ä–∞–≤–∫–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä ({imageBytes.Length / 1024}KB)...");
        
            List<IMultipartFormSection> formData = new List<IMultipartFormSection>();
            formData.Add(new MultipartFormFileSection("file", imageBytes, "screenshot.jpg", "image/jpeg"));
        
            UnityWebRequest request = UnityWebRequest.Post($"{serverUrl}/predict", formData);
            yield return request.SendWebRequest();
        
            if (request.result == UnityWebRequest.Result.Success)
            {
                UnityEngine.Debug.Log("‚Üí –û—Ç–≤–µ—Ç –ø–æ–ª—É—á–µ–Ω, –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é...");
                ProcessPredictions(request.downloadHandler.text);
            }
            else
            {
                UnityEngine.Debug.LogError($"–û—à–∏–±–∫–∞: {request.error}");
            }
        
            Destroy(screenshot);
            request.Dispose();
            isAnalyzing = false;
        }
    
        Texture2D CaptureScreenshot()
        {
            RenderTexture currentRT = RenderTexture.active;
            gameCamera.targetTexture = renderTexture;
            gameCamera.Render();
        
            RenderTexture.active = renderTexture;
            Texture2D screenshot = new Texture2D(224, 224, TextureFormat.RGB24, false);
            screenshot.ReadPixels(new Rect(0, 0, 224, 224), 0, 0);
            screenshot.Apply();
        
            gameCamera.targetTexture = null;
            RenderTexture.active = currentRT;
        
            return screenshot;
        }
    
        void ProcessPredictions(string jsonResponse)
        {
            try
            {
                string wrappedJson = "{\"predictions\":" + jsonResponse + "}";
                PredictionWrapper wrapper = JsonUtility.FromJson<PredictionWrapper>(wrappedJson);
            
                if (wrapper.predictions == null)
                {
                    UnityEngine.Debug.LogWarning("–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –Ω–µ –ø–æ–ª—É—á–µ–Ω—ã!");
                    return;
                }
            
                UnityEngine.Debug.Log($"‚Üí –ü–æ–ª—É—á–µ–Ω–æ {wrapper.predictions.Length} –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π");
            
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ø-5
                var top5 = wrapper.predictions.OrderByDescending(p => p.score).Take(5).ToList();
                foreach (var p in top5)
                {
                    UnityEngine.Debug.Log($"  {p.label}: {p.score:P1}");
                }
            
                var confidentPredictions = wrapper.predictions
                    .Where(p => p.score >= confidenceThreshold)
                    .OrderByDescending(p => p.score)
                    .ToList();
            
                UnityEngine.Debug.Log($"‚Üí –ü—Ä–æ–≤–µ—Ä—è—é —Ç–µ–≥–∏ (–ø–æ—Ä–æ–≥ {confidenceThreshold:P1})...");
                UnityEngine.Debug.Log($"  –ü—Ä–æ—à–ª–æ —Ñ–∏–ª—å—Ç—Ä: {confidentPredictions.Count} –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π");
                CheckEventRules(confidentPredictions);
            }
            catch (System.Exception e)
            {
                UnityEngine.Debug.LogError($"Parse error: {e.Message}");
            }
        }
    
        void CheckEventRules(List<Prediction> predictions)
        {
            float currentTime = Time.time;
        
            UnityEngine.Debug.Log($"CheckEventRules: –ø–æ–ª—É—á–µ–Ω–æ {predictions.Count} –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏");
        
            foreach (var rule in eventRules)
            {
                UnityEngine.Debug.Log($"  –ü—Ä–∞–≤–∏–ª–æ: {rule.eventName}");
                UnityEngine.Debug.Log($"    Cooldown: {currentTime - rule.lastTriggerTime:F1}s / {rule.cooldown}s");
            
                if (currentTime - rule.lastTriggerTime < rule.cooldown)
                {
                    UnityEngine.Debug.Log($"    <color=yellow>–ü–†–û–ü–£–°–ö–ê–ï–ú - cooldown –∞–∫—Ç–∏–≤–µ–Ω</color>");
                    continue;
                }
            
                UnityEngine.Debug.Log($"    –ü—Ä–æ–≤–µ—Ä—è—é {predictions.Count} –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π...");
            
                foreach (var prediction in predictions)
                {
                    UnityEngine.Debug.Log($"      –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ: '{prediction.label}' = {prediction.score:P1}");
                    UnityEngine.Debug.Log($"      –ü–æ—Ä–æ–≥ –ø—Ä–∞–≤–∏–ª–∞: {rule.minConfidence:P1}");
                
                    if (prediction.score < rule.minConfidence)
                    {
                        UnityEngine.Debug.Log($"      <color=red>–ù–ï –ü–†–û–®–õ–û –ü–û–†–û–ì</color>");
                        continue;
                    }
                
                    UnityEngine.Debug.Log($"      <color=green>–ü–†–û–®–õ–û –ü–û–†–û–ì! –ò—â—É —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è...</color>");
                
                    string predLabel = prediction.label.ToLower();
                    string[] labelParts = predLabel.Split(new char[] { ',', ' ' }, StringSplitOptions.RemoveEmptyEntries);
                
                    UnityEngine.Debug.Log($"      –ß–∞—Å—Ç–∏ –º–µ—Ç–∫–∏: [{string.Join(", ", labelParts)}]");
                    UnityEngine.Debug.Log($"      –ò—â—É —Ç–µ–≥–∏: [{string.Join(", ", rule.requiredLabels)}]");
                
                    foreach (var requiredLabel in rule.requiredLabels)
                    {
                        string reqLower = requiredLabel.ToLower();
                        bool matched = labelParts.Any(part => part.Contains(reqLower) || reqLower.Contains(part));
                    
                        if (!matched) matched = predLabel.Contains(reqLower);
                    
                        UnityEngine.Debug.Log($"        –¢–µ–≥ '{reqLower}': {(matched ? "<color=lime>–ù–ê–ô–î–ï–ù!</color>" : "–Ω–µ –Ω–∞–π–¥–µ–Ω")}");
                    
                        if (matched)
                        {
                            UnityEngine.Debug.Log($"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
                            UnityEngine.Debug.Log($"üéØ <color=lime>–¢–ï–ì –ù–ê–ô–î–ï–ù!</color>");
                            UnityEngine.Debug.Log($"–ú–µ—Ç–∫–∞ –ò–ò: '{prediction.label}'");
                            UnityEngine.Debug.Log($"–£–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å: {prediction.score:P1} ({prediction.score:F3})");
                            UnityEngine.Debug.Log($"–°–æ–≤–ø–∞–ª —Å —Ç–µ–≥–æ–º: '{requiredLabel}'");
                            UnityEngine.Debug.Log($"–°–æ–±—ã—Ç–∏–µ: {rule.eventName}");
                            UnityEngine.Debug.Log($"–ü–æ–¥–ø–∏—Å—á–∏–∫–æ–≤: {(rule.onEventTriggered != null ? rule.onEventTriggered.GetPersistentEventCount() : 0)}");
                            UnityEngine.Debug.Log($"–í—ã–∑—ã–≤–∞—é —Å–æ–±—ã—Ç–∏–µ...");
                            UnityEngine.Debug.Log($"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
                        
                            rule.onEventTriggered?.Invoke();
                            rule.lastTriggerTime = currentTime;
                            return;
                        }
                    }
                }
            }
        
            UnityEngine.Debug.Log("<color=yellow>–ù–ò –û–î–ò–ù –¢–ï–ì –ù–ï –°–û–í–ü–ê–õ!</color>");
        }
    
        void OnDestroy()
        {
            if (renderTexture != null) renderTexture.Release();
        }
    }
}

